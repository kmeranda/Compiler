/*
Main program of calculator example.
Simply invoke the parser generated by bison, and then display the output.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "token.h"
#include "scope.h"
#include "symbol.h"
//#include "expr.h"
//#include "stmt.h"
//#include "type.h"
#include "decl.h"
//#include "parser.tab.h"

extern int yyparse();
extern int yylex();
extern struct decl * program;
extern struct hash_table * h;
int error_count = 0;
int reg[16] = {1,0,1,1,1,1,1,1,1,1,0,0,0,0,0};	// 0 = free, 1 = allocated
int label_count = 0;
int string_count = 0;
int ret_count = 0;
int arg_count = 0;

int codegen(char * input, char * output);
int typecheck(char * file);
int resolve(char * file);
int parse(char * file, int print);
void scan(char * file);
void edit_string (char * s);

int main( int argc, char *argv[] ) {
	int result;
	if (!strcmp(argv[1], "-scan")) {
		scan(argv[2]);
	}
	else if (!strcmp(argv[1], "-parse")) {
		result = parse(argv[2], 1);	
	}
	else if (!strcmp(argv[1], "-print")) {
		result = parse(argv[2], 1);
	}
	else if (!strcmp(argv[1], "-resolve")) {
		result = resolve(argv[2]);	
	}
	else if (!strcmp(argv[1], "-typecheck")) {
		result = typecheck(argv[2]);	
	}
	else if (!strcmp(argv[1], "-codegen")) {
		result = codegen(argv[2], argv[3]);
	}
	else {
		printf("incorrect flag\n");
	}
	return result;
}

int codegen(char * input, char * output) {
	extern FILE * yyin;
	extern char * yytext;
	yyin = fopen(input, "r");
	if (!yyin) {
		printf("invalid file.\n");
	}
	if(yyparse()==0) {

		h = hash_table_create(0,0);
		decl_resolve(program);
		if (error_count > 0) {
			printf("%d name resolution errors.\n", error_count);
			return 1;
		}
		decl_typecheck(program);
		printf("%d typecheck errors\n", error_count);
		if (error_count > 0) {
			return 1;
		}
		//decl_print(program, 0);
		FILE * out;
		out = fopen(output, "w");
		decl_codegen(program, out);
		fclose(out);
		return 0;
	} else {
		printf("parse failed!\n");
		return 1;
	}	
}

int typecheck(char * file) {
	extern FILE * yyin;
	extern char * yytext;
	yyin = fopen(file, "r");
	if (!yyin) {
		printf("invalid file.\n");
	}
	if(yyparse()==0) {
		h = hash_table_create(0,0);
		decl_resolve(program);
		if (error_count > 0) {
			printf("%d name resolution errors.\n", error_count);
			return 1;
		}
		decl_typecheck(program);
		printf("%d typecheck errors\n", error_count);
		if (error_count > 0) {
			return 1;
		}
		return 0;
	} else {
		printf("parse failed!\n");
		return 1;
	}
}

int resolve(char * file) {
	extern FILE * yyin;
	extern char * yytext;
	yyin = fopen(file, "r");
	if (!yyin) {
		printf("invalid file.\n");
		return 1;
	}
	if(yyparse()==0) {
		h = hash_table_create(0,0);
		decl_resolve(program);
		printf("%d name resolution errors.\n", error_count);
		if (error_count > 0) { return 1; }
		return 0;
	} else {
		printf("parse failed!\n");
		return 1;
	}	
}

int parse(char * file, int print) {
	extern FILE * yyin;
	extern char * yytext;
	yyin = fopen(file, "r");
	if (!yyin) {
		printf("invalid file.\n");
		return 2;
	}
	if(yyparse()==0) {
		printf("parse successful");
		if (print)
			decl_print(program, 0);
		printf("\n");
		return 0;
	} else {
		printf("parse failed!\n");
		return 1;
	}
}

void scan(char * file) {
	extern FILE * yyin;
	extern char * yytext;
	yyin = fopen(file,"r");
	while (1) {
		int t = yylex();
		if (yytext[0]=='\0') {
			exit(0);
			break;
		}
		if (t==NOT_TOKEN) {
			fprintf(stderr, "scan error: %s is not a valid character\n", yytext);
			exit(1);
			break;
		}
		else if (!t) {
			exit(0);
			break; 
		}
		else {
			if (t==TOKEN_STRING_LITERAL /*|| t==TOKEN_INT_LITERAL */|| t==TOKEN_CHAR_LITERAL) {
				if (t!=TOKEN_INT_LITERAL) 
					edit_string(yytext);
				if (strlen(yytext)>255 && t==TOKEN_STRING_LITERAL) {
					fprintf(stderr, "scan error: string too long\n");
					exit(1);
				}
				else {
					printf("%s %s\n", token_string(t), yytext);
				}
			}
			else {
				if (strlen(yytext)<256 || t!=TOKEN_IDENT) {
					printf("%s\n", token_string(t));
				}
				else {
					fprintf(stderr, "scan error: identifier too long\n");
					exit(1);
				}
			}
		}
	}
	return;
}

void edit_string (char * s) {
	int i, j;
	for (j=1; j<strlen(s); j++) {	// remove "/'
		s[j-1] = s[j];
	}
	s[j-2]='\0';	// end quote removed
	for (i=0; i<strlen(s); i++) {	// scan string
		if (s[i]=='\\') {
			if (s[i+1]=='0') {
				s[i] = '\0';
			}
			else if (s[i+1]=='n') {
				s[i] = '\n';
			}
			else if (s[i+1]=='t') {
				s[i] = '\t';
			}
			else {
				s[i] = s[i+1];
			}
			for (j=i+1; j<strlen(s); j++) {	// remove '\'
				s[j] = s[j+1];
			}
			s[j] = '\0';
		}
	}
}
